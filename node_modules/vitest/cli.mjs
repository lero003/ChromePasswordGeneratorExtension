#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { pathToFileURL } from 'node:url';

const contextKey = Symbol.for('mini-vitest-context');

function format(value) {
  if (typeof value === 'string') return `"${value}"`;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  if (Array.isArray(value)) return `[${value.map(format).join(', ')}]`;
  if (value === null) return 'null';
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

function createExpect(received) {
  const base = {
    toBe(expected) {
      if (received !== expected) {
        throw new Error(`Expected ${format(received)} to be ${format(expected)}`);
      }
    },
    toHaveLength(expected) {
      if (received == null || typeof received.length !== 'number') {
        throw new Error(`Expected value with a length but received ${format(received)}`);
      }
      if (received.length !== expected) {
        throw new Error(`Expected length ${expected} but received ${received.length}`);
      }
    },
    toBeGreaterThanOrEqual(expected) {
      if (!(received >= expected)) {
        throw new Error(`Expected ${format(received)} to be greater than or equal to ${format(expected)}`);
      }
    },
    toMatch(pattern) {
      const regex = pattern instanceof RegExp ? pattern : new RegExp(String(pattern));
      if (!regex.test(received)) {
        throw new Error(`Expected ${format(received)} to match ${regex}`);
      }
    },
    toThrow() {
      if (typeof received !== 'function') {
        throw new Error('toThrow matcher requires a function');
      }
      let didThrow = false;
      try {
        received();
      } catch (error) {
        didThrow = true;
      }
      if (!didThrow) {
        throw new Error('Expected function to throw, but it did not.');
      }
    },
  };

  Object.defineProperty(base, 'not', {
    enumerable: true,
    get() {
      return {
        toBe(expected) {
          if (received === expected) {
            throw new Error(`Expected ${format(received)} not to be ${format(expected)}`);
          }
        },
      };
    },
  });

  return base;
}

function createRunner() {
  const tests = [];
  const suites = [];

  function currentPrefix() {
    return suites.join(' › ');
  }

  function describe(name, fn) {
    suites.push(name);
    try {
      fn();
    } finally {
      suites.pop();
    }
  }

  function it(name, fn) {
    const prefix = currentPrefix();
    const title = prefix ? `${prefix} › ${name}` : name;
    tests.push({ name: title, fn });
  }

  async function run() {
    let passed = 0;
    let failed = 0;
    for (const test of tests) {
      try {
        await Promise.resolve(test.fn());
        console.log(`✓ ${test.name}`);
        passed += 1;
      } catch (error) {
        console.log(`✗ ${test.name}`);
        if (error instanceof Error) {
          console.error(error.stack || error.message);
        } else {
          console.error(error);
        }
        failed += 1;
      }
    }
    console.log(`\n${passed} passed, ${failed} failed`);
    if (failed > 0) {
      process.exitCode = 1;
    }
  }

  return {
    describe,
    it,
    expect: (value) => createExpect(value),
    run,
  };
}

function collectTestsFromDir(dir, result) {
  if (!fs.existsSync(dir)) return;
  const entries = fs.readdirSync(dir);
  for (const entry of entries) {
    const full = path.join(dir, entry);
    const stat = fs.statSync(full);
    if (stat.isDirectory()) {
      collectTestsFromDir(full, result);
    } else if (entry.endsWith('.test.js')) {
      result.add(path.resolve(full));
    }
  }
}

function resolveTestFiles(patterns) {
  const files = new Set();
  if (!patterns || patterns.length === 0) {
    collectTestsFromDir(path.resolve('tests'), files);
    return Array.from(files).sort();
  }

  for (const pattern of patterns) {
    if (pattern.startsWith('tests/')) {
      collectTestsFromDir(path.resolve(pattern.split('**')[0] || 'tests'), files);
    } else if (!pattern.includes('*')) {
      const absolute = path.resolve(pattern);
      if (fs.existsSync(absolute)) {
        files.add(absolute);
      }
    }
  }

  return Array.from(files).sort();
}

async function loadConfig() {
  const configPath = path.resolve('vitest.config.js');
  if (!fs.existsSync(configPath)) {
    return { test: { include: ['tests/**/*.test.js'] } };
  }
  const module = await import(pathToFileURL(configPath));
  return module.default ?? module;
}

(async function main() {
  const argv = process.argv.slice(2);
  if (argv[0] === 'run') {
    argv.shift();
  }

  const runner = createRunner();
  globalThis[contextKey] = {
    describe: runner.describe,
    it: runner.it,
    expect: runner.expect,
  };

  const config = await loadConfig();
  const includePatterns = config?.test?.include || ['tests/**/*.test.js'];
  const files = resolveTestFiles(includePatterns);

  if (files.length === 0) {
    console.log('No test files found.');
    process.exit(0);
  }

  for (const file of files) {
    await import(pathToFileURL(file));
  }

  await runner.run();

  delete globalThis[contextKey];
})();
